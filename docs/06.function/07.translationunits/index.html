<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ch6.7: Translation Units - C++ Tutorial</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="manifest" href="/manifest.json">
  <link rel="icon" type="image/webp" href="/icons/logo.webp">
</head>
<body>
  <main>
    <h1>Ch6.7: Translation Units</h1>

    <section>
      <h2>Overview</h2>
      <p>
        C++ programs are often split across multiple files. Each file is compiled
        separately into a <strong>translation unit</strong>, and the linker combines
        all translation units into a final executable.
      </p>

      <p>
        Modern C++ also introduces <strong>modules</strong>, which are compiled
        translation units that replace many uses of header files.
      </p>

      <p>In this chapter, you will learn:</p>

      <ul>
        <li>what a translation unit is</li>
        <li>how declarations and definitions are organized</li>
        <li>how separate compilation works</li>
        <li>how C++ modules relate to translation units</li>
        <li>how to write and compile a simple module</li>
      </ul>
    </section>

    <!-- ========================= -->
    <!-- 1. WHAT IS A TRANSLATION UNIT -->
    <!-- ========================= -->

    <section>
      <h2>1. What is a translation unit?</h2>
      <p>
        A <strong>translation unit</strong> is the result of taking a single
        <code>.cpp</code> file, applying the preprocessor (<code>#include</code>,
        <code>#define</code>, etc.), and producing one large file that the compiler
        actually compiles.
      </p>

<pre><code class="language-text">
main.cpp        → translation unit A
math.cpp        → translation unit B
io.cpp          → translation unit C
</code></pre>

      <p>
        Each translation unit is compiled independently into an object file:
      </p>

<pre><code class="language-text">
main.cpp  → main.o
math.cpp  → math.o
io.cpp    → io.o
</code></pre>

      <p>
        The linker then combines all object files into a single executable.
      </p>
    </section>

    <!-- ========================= -->
    <!-- 2. DECLARATIONS VS DEFINITIONS -->
    <!-- ========================= -->

    <section>
      <h2>2. Declarations vs. definitions</h2>
      <p>
        When working with multiple translation units, it is essential to separate
        <strong>declarations</strong> from <strong>definitions</strong>.
      </p>

      <ul>
        <li><strong>Declarations</strong> tell the compiler that something exists.</li>
        <li><strong>Definitions</strong> provide the full body or allocate storage.</li>
      </ul>

      <p>
        Declarations belong in <strong>header files</strong> (<code>.hpp</code>).
        Definitions belong in <strong>source files</strong> (<code>.cpp</code>).
      </p>

<pre><code class="language-cpp">
// math.hpp (declaration)
int square(int x);
</code></pre>

<pre><code class="language-cpp">
// math.cpp (definition)
int square(int x)
{
    return x * x;
}
</code></pre>

<pre><code class="language-cpp">
// main.cpp
#include "math.hpp"

int main()
{
    ::fast_io::println(square(5));
}
</code></pre>
    </section>

    <!-- ========================= -->
    <!-- 3. COMPILING MULTIPLE FILES -->
    <!-- ========================= -->

    <section>
      <h2>3. Compiling multiple files</h2>
      <p>
        You can compile and link multiple translation units in one command:
      </p>

<pre><code class="language-bash">
clang++ -std=c++23 main.cpp math.cpp -o program
</code></pre>

      <p>or with <code>g++</code>:</p>

<pre><code class="language-bash">
g++ -std=c++23 main.cpp math.cpp -o program
</code></pre>

      <p>
        Or compile each translation unit separately and link later:
      </p>

<pre><code class="language-bash">
clang++ -std=c++23 -c main.cpp   # produces main.o
clang++ -std=c++23 -c math.cpp   # produces math.o
clang++ main.o math.o -o program
</code></pre>
    </section>

    <!-- ========================= -->
    <!-- 4. MODULES AS TRANSLATION UNITS -->
    <!-- ========================= -->

    <section>
      <h2>4. Modules as translation units</h2>
      <p>
        A C++ module interface file (<code>.cppm</code>) is also a translation unit.
        Instead of using <code>#include</code> to copy text, modules use
        <strong>export</strong> and <strong>import</strong> to share compiled
        declarations.
      </p>

<pre><code class="language-text">
math.cppm  → translation unit (module interface)
main.cpp   → translation unit (imports the module)
</code></pre>

      <p>
        The compiler produces a <strong>PCM</strong> (precompiled module) from the
        module interface, and other translation units import it.
      </p>
    </section>

    <!-- ========================= -->
    <!-- 5. WRITING AND COMPILING A MODULE -->
    <!-- ========================= -->

    <section>
      <h2>5. Writing and compiling a simple module</h2>

      <p>
        A module interface declares a module and exports the functions or types
        you want other translation units to use.
      </p>

<pre><code class="language-cpp">
// math.cppm — module interface
export module math;

export int square(int x)
{
    return x * x;
}
</code></pre>

      <p>
        A separate translation unit can import the module:
      </p>

<pre><code class="language-cpp">
// main.cpp
import math;
import fast_io;

int main()
{
    ::fast_io::println(square(7));
}
</code></pre>

      <h3>Compiling the module with Clang</h3>

      <h4>Step 1 — Compile the module interface</h4>

<pre><code class="language-bash">
clang++ -std=c++26 --precompile math.cppm -o math.pcm
</code></pre>

      <h4>Step 2 — Compile your program and import the PCM</h4>

<pre><code class="language-bash">
clang++ -std=c++26 -fmodule-file=math=math.pcm -c main.cpp -o main.o
</code></pre>

      <h4>Step 3 — Link the final executable</h4>

<pre><code class="language-bash">
clang++ main.o -o program
</code></pre>

      <h3>Optional: Compiling the fast_io module</h3>

<pre><code class="language-bash">
clang++ -std=c++26 --precompile \
  $HOME/libraries/fast_io/share/fast_io/fast_io.cppm \
  -I$HOME/libraries/fast_io/include \
  -o fast_io.pcm
</code></pre>

<pre><code class="language-bash">
clang++ -std=c++26 \
  -fmodule-file=math=math.pcm \
  -fmodule-file=fast_io=fast_io.pcm \
  -c main.cpp -o main.o
</code></pre>

<pre><code class="language-bash">
clang++ main.o -o program
</code></pre>
    </section>

    <!-- ========================= -->
    <!-- SUMMARY -->
    <!-- ========================= -->

    <section>
      <h2>Key takeaways</h2>
      <ul>
        <li>Each <code>.cpp</code> file becomes a separate translation unit.</li>
        <li>Module interface files (<code>.cppm</code>) are also translation units.</li>
        <li>The compiler compiles each translation unit independently.</li>
        <li>The linker combines object files into a final executable.</li>
        <li>Modules replace textual inclusion with compiled interfaces.</li>
        <li>Clang uses PCMs (<code>.pcm</code>) to represent compiled modules.</li>
      </ul>
    </section>

    <script src="/sw-register.js"></script>
    <div class="page-navigation">
      <a href="/docs/06.function/06.overloading/" class="prev-button">← Ch6.6: Function Overloading</a>
      <a href="/" class="main-button">↑ Main Page</a>
      <a href="/docs/06.function/08.inline/" class="next-button">Ch6.8: Inline Functions →</a>
    </div>
  </main>
</body>
</html>
