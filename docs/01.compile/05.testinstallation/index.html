<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ch1.5: Test Installation - C++ Tutorial with fast_io</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="manifest" href="/manifest.json">
  <link rel="icon" type="image/webp" href="/icons/logo.webp">
</head>
<body>
  <main>
    <h1>Ch1.5: Test Installation</h1>

    <section>
      <h2>Create a Simple Test Program</h2>
      <p>
        After installing the toolchains in <em>Ch1.4</em>, you should verify that your compiler works correctly.
        Use any text editor you prefer — VS Code PWA, Vim, Notepad, or others — and create a file named
        <code>hello.cpp</code>.
      </p>
      <p>
        Although this tutorial uses the <strong>fast_io</strong> library instead of <code>iostream</code>,
        a traditional C++ “Hello World” program is still the simplest way to test your installation:
      </p>

      <pre><code>#include &lt;iostream&gt;

int main()
{
    ::std::cout &lt;&lt; "Hello World\n";
}</code></pre>

      <p>
        If this program compiles and runs, your installation is functioning correctly.
      </p>
    </section>

    <section>
      <h2>Clang Configuration Files</h2>
      <p>
        The installation scripts from <em>Ch1.4</em> automatically generate Clang configuration files using
        <code>create_cfgs.sh</code> or <code>create_cfgs.ps1</code>. These files are stored in:
      </p>
      <ul>
        <li><strong>Linux / macOS / Android:</strong> <code>$HOME/cfgs</code></li>
        <li><strong>Windows:</strong> <code>%USERPROFILE%/cfgs</code></li>
      </ul>
      <p>
        A Clang <strong>.cfg</strong> file simply appends compiler flags automatically. You can open them in a text
        editor to inspect the exact compilation options.
      </p>
    </section>

    <section>
      <h2>1. Build a Windows Binary (Cross‑Compilation)</h2>
      <p>
        On all operating systems except macOS, you can create Windows binaries using Clang. Wine (version 10 or newer)
        allows you to run these binaries on Linux, musl, or Android.
      </p>

      <h3>Linux / BSD / Android</h3>
      <pre><code>clang++ -o hello.exe hello.cpp -O3 \
  --sysroot=$HOME/toolchains/windows-msvc-sysroot \
  -fuse-ld=lld -flto=thin \
  --target=x86_64-windows-msvc
wine ./hello.exe</code></pre>

      <p>If you are on an ARM device (Android, tablets, VR devices), use:</p>
      <pre><code>--target=aarch64-windows-msvc</code></pre>

      <h3>Windows (CMD)</h3>
      <pre><code>clang++ -o hello.exe hello.cpp -O3 ^
  --sysroot=%USERPROFILE%/toolchains/windows-msvc-sysroot ^
  -fuse-ld=lld ^
  --target=x86_64-windows-msvc
hello.exe</code></pre>

      <h3>Windows (PowerShell)</h3>
      <pre><code>clang++ -o hello.exe hello.cpp -O3 `
  --sysroot=$env:USERPROFILE/toolchains/windows-msvc-sysroot `
  -fuse-ld=lld -flto=thin `
  --target=x86_64-windows-msvc
./hello.exe</code></pre>

      <p>
        These commands produce a Windows binary linked against the Microsoft Visual C++ runtime. Wine provides its own
        implementation, so you do <strong>not</strong> need to install anything extra on Linux.
      </p>

      <h3>Alternative Linking Example</h3>
      <pre><code>clang++ -o hello.exe hello.cpp -O3 \
  --sysroot=$HOME/toolchains/windows-msvc-sysroot \
  -fuse-ld=lld -D_DLL=1 -lmsvcrt
wine ./hello.exe</code></pre>

      <h3>Using the Generated CFG Files</h3>
      <pre><code>clang++ -o hello.exe hello.cpp -O3 \
  --config=$HOME/cfgs/x86_64-windows-msvc.cfg
wine ./hello.exe</code></pre>

      <p>To cross‑compile for ARM Windows:</p>
      <pre><code>clang++ -o hello.exe hello.cpp -O3 \
  --config=$HOME/cfgs/aarch64-windows-msvc.cfg</code></pre>

      <p>
        You can then copy the binary to your ARM device (Android, etc.) and run it with Wine.
      </p>

      <h3>Windows Runtime Notes</h3>
      <ul>
        <li>Most Windows systems already include the MSVC runtime.</li>
        <li>If DLLs are missing, install the latest redistributable:</li>
        <li><a href="https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist" target="_blank" rel="noopener noreferrer">Microsoft VC Redistributable</a></li>
        <li>Windows on ARM users should install x86, x64, and arm64 redistributables.</li>
      </ul>

      <h3>Using Wine to Run Clang Itself</h3>
      <p>
        The script in <em>Ch1.4</em> also installs a Windows Clang toolchain on Linux. You can invoke it through Wine:
      </p>

      <pre><code>wine clang++ -o hello.exe hello.cpp -O3 \
  --config=$HOME/cfgs/aarch64-windows-msvc.cfg
wine ./hello.exe</code></pre>
    </section>

    <section>
      <h2>2. Build a Native Binary</h2>
      <p>To determine your platform’s target triple, run:</p>
      <pre><code>clang++ -v</code></pre>

      <p>Example output on macOS:</p>
      <pre><code>Target: aarch64-apple-darwin24.4.0</code></pre>

      <p>
        The important part is the triplet: <strong>aarch64-apple-darwin24</strong>.  
        The toolchains from <code>llvm-releases</code> include many common triplets:
      </p>

      <ul>
        <li>aarch64-apple-darwin24</li>
        <li>aarch64-linux-android30</li>
        <li>aarch64-windows-gnu</li>
        <li>x86_64-linux-gnu</li>
        <li>x86_64-windows-gnu</li>
        <li>wasm64-wasip1</li>
      </ul>

      <h3>Compile a Native Binary</h3>
      <pre><code>clang++ -o hello hello.cpp -O3 -flto=thin \
  --config=$HOME/cfgs/aarch64-apple-darwin24.cfg
./hello</code></pre>

      <p>
        On macOS, this produces a <strong>universal binary</strong> containing both x86_64 and aarch64 slices, so it also
        runs on Intel Macs and Hackintosh systems.
      </p>

      <p>
        Creating a platform‑specific binary does not necessarily make it more “native” than running a Windows binary
        through Wine. Wine is a compatibility layer, not an emulator, and avoids issues like glibc version mismatches.
      </p>
    </section>

    <section>
      <h2>3. Build a WebAssembly Binary</h2>

      <h3>What Is Bytecode?</h3>
      <p>
        WebAssembly is a <strong>bytecode format</strong> — a compact, platform‑independent instruction set.
        Bytecode is not tied to any CPU architecture. Instead, it is executed by a virtual machine or JIT compiler.
      </p>

      <h3>How WebAssembly Compares to Java Bytecode</h3>
      <ul>
        <li><strong>Java bytecode</strong> runs on the JVM, which provides garbage collection, threads, exceptions, and a large runtime.</li>
        <li><strong>WebAssembly bytecode</strong> is much lower‑level and closer to native machine code.</li>
        <li>WASM does <strong>not</strong> include garbage collection, threads (unless WASM threads are enabled), or exceptions.</li>
        <li>WASM is designed for portability and sandboxing, not for running Java‑style managed languages.</li>
      </ul>

      <p>
        In other words:  
        <strong>Java bytecode is a managed runtime format.  
        WebAssembly is a portable machine‑code‑like format.</strong>
      </p>

      <h3>WAVM Is Not a Toolchain</h3>
      <p>
        WAVM is a <strong>WebAssembly virtual machine</strong>, not a compiler.  
        Clang produces the WebAssembly binary. WAVM simply runs it.
      </p>

      <h3>Compile to WebAssembly</h3>
      <pre><code>clang++ -o hello hello.cpp -O3 -flto=thin \
  --config=$HOME/cfgs/wasm64-wasip1-noeh.cfg -s</code></pre>

      <h3>Run with WAVM</h3>
      <pre><code>wavm run --enable memtag --mount-root . ./hello</code></pre>

      <p>
        WebAssembly Memory Tagging is based on the author’s Ph.D. research  
        (<a href="https://dl.acm.org/doi/10.1145/3733812.3765536" target="_blank" rel="noopener noreferrer">ACM CCSW 2025</a>).
        It helps detect memory safety bugs and will be used later in this tutorial.
      </p>
    </section>

    <script src="/sw-register.js"></script>
    <div class="page-navigation">
      <a href="/docs/01.compile/04.clang/" class="prev-button">← Ch1.4: Clang</a>
      <a href="/" class="main-button">↑ Main Page</a>
      <a href="/docs/01.compile/06.gcc/" class="next-button">Ch1.6: GCC →</a>
    </div>
  </main>
</body>
</html>
