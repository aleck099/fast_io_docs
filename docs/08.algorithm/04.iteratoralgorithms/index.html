<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ch8.4: Iterator Algorithms - C++ Tutorial with fast_io</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="manifest" href="/manifest.json">
  <link rel="icon" type="image/webp" href="/icons/logo.webp">
</head>
<body>
  <main>
    <h1>Ch8.4: Iterator Algorithms</h1>

    <section>
      <h2>Overview</h2>

      <p>
        Algorithms operate on iterators.  
        They do not know or care about the underlying container; they only require
        certain iterator capabilities.
      </p>

      <p>
        In this chapter, you will learn:
      </p>

      <ul>
        <li>how algorithms depend on iterator categories</li>
        <li>which algorithms require which iterator strengths</li>
        <li>how to reason about algorithm preconditions</li>
        <li>how contiguous iterators enable fast paths</li>
        <li>how to detect iterator and range capabilities with <code>if constexpr</code></li>
        <li>how iterator algorithms and ranges algorithms relate</li>
      </ul>
    </section>

    <section>
      <h2>1. Algorithms depend on iterator capabilities</h2>

      <p>
        Every algorithm has <strong>minimum iterator requirements</strong>.
        These requirements determine whether the algorithm can:
      </p>

      <ul>
        <li>read elements</li>
        <li>write elements</li>
        <li>traverse multiple times</li>
        <li>move backward</li>
        <li>jump to arbitrary positions</li>
      </ul>

      <p>
        Stronger iterator categories enable stronger algorithms.
      </p>
    </section>

    <section>
      <h2>2. The capability ladder for algorithms</h2>

<pre><code>
input_iterator
    ↓
forward_iterator
    ↓
bidirectional_iterator
    ↓
random_access_iterator
    ↓
contiguous_iterator
</code></pre>

      <p>
        Each step adds new algorithmic possibilities.
      </p>
    </section>

    <section>
      <h2>3. Algorithms requiring input_iterator</h2>

      <p>
        These algorithms only need to read elements once, moving forward:
      </p>

      <ul>
        <li><code>find</code></li>
        <li><code>count</code></li>
        <li><code>for_each</code></li>
      </ul>

      <p>
        They work on the weakest readable iterators.
      </p>
    </section>

    <section>
      <h2>4. Algorithms requiring forward_iterator</h2>

      <p>
        These algorithms require multiple passes over the same elements:
      </p>

      <ul>
        <li><code>remove</code></li>
        <li><code>unique</code></li>
        <li><code>replace</code></li>
      </ul>

      <p>
        A forward_iterator guarantees multi-pass traversal.
      </p>
    </section>

    <section>
      <h2>5. Algorithms requiring bidirectional_iterator</h2>

      <p>
        These algorithms require backward movement:
      </p>

      <ul>
        <li><code>reverse</code></li>
        <li><code>rotate</code> (bidirectional version)</li>
      </ul>
    </section>

    <section>
      <h2>6. Algorithms requiring random_access_iterator</h2>

      <p>
        These algorithms require constant-time jumps:
      </p>

      <ul>
        <li><code>sort</code></li>
        <li><code>nth_element</code></li>
        <li><code>binary_search</code></li>
      </ul>

      <p>
        Random access enables indexing and partitioning.
      </p>

      <h3>Iterator algorithms</h3>

      <p>
        Iterator algorithms operate directly on iterator pairs:
      </p>

<pre><code class="language-cpp">
::std::sort(vec.begin(), vec.end());
</code></pre>

      <p>
        This form requires a <code>random_access_iterator</code>.
      </p>

      <h3>Ranges algorithms</h3>

      <p>
        Ranges algorithms can also accept iterator pairs:
      </p>

<pre><code class="language-cpp">
::std::ranges::sort(vec.begin(), vec.end());
</code></pre>

      <p>
        Or the entire range directly:
      </p>

<pre><code class="language-cpp">
::std::ranges::sort(vec);
</code></pre>

      <p>
        Both forms require the same iterator category.
      </p>

      <h3>Algorithms with comparison objects</h3>

      <p>
        Algorithms can accept comparison objects from <code>&lt;functional&gt;</code>.
        These work with both iterator algorithms and ranges algorithms.
      </p>

      <p>Iterator algorithm form:</p>

<pre><code class="language-cpp">
::std::sort(vec.begin(), vec.end(), ::std::greater&lt;&gt;{});
</code></pre>

      <p>Ranges algorithm form (iterator pair):</p>

<pre><code class="language-cpp">
::std::ranges::sort(vec.begin(), vec.end(), ::std::ranges::greater{});
</code></pre>

      <p>Ranges algorithm form (entire range):</p>

<pre><code class="language-cpp">
::std::ranges::sort(vec, ::std::ranges::greater{});
</code></pre>

      <p>
        The comparison object does not change the iterator category requirements.
      </p>
    </section>

    <section>
      <h2>7. Algorithms benefiting from contiguous_iterator</h2>

      <p>
        A contiguous_iterator allows the compiler to reason about memory layout.
        This enables optimizations such as:
      </p>

      <ul>
        <li>vectorized operations</li>
        <li>memcpy-class fast paths</li>
        <li>loop unrolling</li>
      </ul>

      <p>
        Pointers to object types and <code>::fast_io::vector&lt;T&gt;</code> iterators
        are contiguous_iterators.
      </p>
    </section>

    <section>
      <h2>8. fast_io containers and iterator algorithms</h2>

      <p>
        <code>::fast_io::vector&lt;T&gt;</code> provides contiguous iterators.
        Algorithms that require random access or benefit from contiguity
        will use the strongest available path.
      </p>

      <p>
        Other fast_io containers follow the same iterator rules as their STL counterparts.
      </p>
    </section>

    <section>
      <h2>9. Detecting algorithm applicability with <code>if constexpr</code></h2>

      <p>
        You can write algorithms that adapt to iterator or range strength. The type is
        deduced from the function parameter, and <code>if constexpr</code> selects the
        appropriate path at compile time.
      </p>

      <h3>Iterator version</h3>

<pre><code class="language-cpp">
template &lt;typename It&gt;
void analyze(It first, It last)
{
    if constexpr(::std::random_access_iterator&lt;It&gt;)
        print("iterator: random-access fast path\n");
    else
        print("iterator: generic path\n");
}
</code></pre>

      <p>Calling it is straightforward:</p>

<pre><code class="language-cpp">
int arr[]{1,2,3,4};
analyze(arr, arr + 4);                 // arr decays to int*
</code></pre>

<pre><code class="language-cpp">
::fast_io::vector&lt;int&gt; vec{1,2,3,4};
analyze(vec.begin(), vec.end());       // deduces ::fast_io::vector&lt;int&gt;::iterator
</code></pre>

      <h3>Range version</h3>

      <p>
        You can also write an overload that accepts an entire range:
      </p>

<pre><code class="language-cpp">
template &lt;typename T&gt;
void analyze(T&amp; r)
{
    if constexpr(::std::ranges::random_access_range&lt;T&gt;)
        print("range: random-access fast path\n");
    else
        print("range: generic path\n");
}
</code></pre>

      <p>Calling the range version:</p>

<pre><code class="language-cpp">
analyze(vec);                          // detects random_access_range
</code></pre>

      <p>
        Both overloads adapt automatically based on iterator or range category.
      </p>
    </section>

    <section>
      <h2>10. Common pitfalls</h2>

      <ul>
        <li>using multi-pass algorithms on input_iterators</li>
        <li>using random-access algorithms on bidirectional_iterators</li>
        <li>invalidating iterators during modification</li>
        <li>passing overlapping ranges to algorithms that forbid them</li>
      </ul>
    </section>

    <section>
      <h2>Key takeaways</h2>

      <ul>
        <li>Algorithms depend on iterator categories.</li>
        <li>Stronger iterators enable stronger algorithms.</li>
        <li>Contiguous iterators allow the fastest optimizations.</li>
        <li>Iterator algorithms and ranges algorithms both operate on iterators.</li>
        <li>Comparison objects from &lt;functional&gt; work with both forms.</li>
        <li><code>if constexpr</code> allows algorithms to adapt to iterator or range strength.</li>
      </ul>
    </section>

    <script src="/sw-register.js"></script>
    <div class="page-navigation">
      <a href="/docs/08.algorithm/03.iteratorcategories/" class="prev-button">← Ch8.3: Iterator Categories</a>
      <a href="/" class="main-button">↑ Main Page</a>
      <a href="/docs/08.algorithm/05.nextchapter/" class="next-button">Ch8.5 →</a>
    </div>

  </main>
</body>
</html>
